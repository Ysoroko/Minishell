/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   msh.c                                              :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ablondel <ablondel@student.s19.be>         +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2021/07/21 11:32:44 by ablondel          #+#    #+#             */
/*   Updated: 2021/07/21 18:24:42 by ablondel         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "msh.h"

int	ft_strlen(char *s)
{
	int i;

	i = 0;
	while (s[i])
		i++;
	return (i);
}

int	ft_count_env(char *s)
{
	int	n;

	n = 1;
	while (*s)
	{
		if (*s == ':')
			n++;
		s++;
	}
	return (n);
}

int		ft_strncmp(char *s1, char *s2, unsigned int n)
{
	unsigned int i;

	i = 0;
	while (s1[i] && s2[i] && i < (n - 1))
	{
		if (s1[i] != s2[i])
			return (s1[i] - s2[i]);
		i++;
	}
	return (s1[i] - s2[i]);
}

char	*ft_dup_path(char *path)
{
	char *dst;
	int i;
	int len;

	dst = NULL;
	i = -1;
	len = 0;
	while (path[len])
		len++;
	dst = malloc(sizeof(char) * (len + 1));
	if (!dst)
		return (NULL);
	while (path[++i])
		dst[i] = path[i];
	dst[i] = '\0';
	return (dst);
}

char	*ft_get_paths(char **env)
{
	unsigned int i;
	char	*dst;

	i = 0;
	dst = NULL;
	while (env[i])
	{
		if (ft_strncmp("PATH=", env[i], 4) == 0)
		{
			dst = ft_dup_path(env[i] + 5);
			if (!dst)
				return (NULL);
		}
		i++;
	}
	return (dst);
}

char	**ft_split_env(t_msh *add, char *paths_var, char **paths)
{
	add->i = -1;
	add->j = 0;
	add->k = 0;
	paths = NULL;
	paths = (char **)malloc(sizeof(char *) * (ft_count_env(paths_var) + 1));
	if (!paths)
		return (NULL);
	while (++add->i < ft_count_env(paths_var))
	{
		paths[add->i] = (char *)malloc(sizeof(char) * (ft_strlen(paths_var) + 1));
		if (!paths[add->i])
			return (0);
		while (paths_var[add->j] && paths_var[add->j] == ':')
			add->j++;
		while (paths_var[add->j] && paths_var[add->j] != ':')
			paths[add->i][add->k++] = paths_var[add->j++];
		paths[add->i][add->k] = '\0';
		add->k = 0;
	}
	paths[add->i] = NULL;
	return (paths);
}

int	file_exec_check(t_msh *add, char *file)
{
	int i = 0;
	DIR	*dir;
	struct dirent *p;

	if (!file)
		return (-1);
	while (add->paths[i])
	{
		dir = opendir(add->paths[i]);
		while ((p = readdir(dir)) != NULL)
		{
			if (strcmp(file, p->d_name) == 0)
			{
				printf("\033[0;32m");
				printf("\n{%s} exists in the directory {%s} as: [%s]\n", file, add->paths[i], ft_strjoin(add->paths[i], file));
				printf("\033[0;37m");
				return (1);
			}
		}
		closedir(dir);
		i++;
	}
	printf("\033[0;31m");
	printf("\n{%s} does not exists in any directory specified by the PATH variable\n", file);
	printf("\033[0;37m");
	return (-1);
}

int	file_type_check(t_msh *add, char *file)
{
	struct stat sb;
	file_exec_check(add, file);
	if (stat(file, &sb) == 0)
	{
		printf("\033[0;32m");
		printf("file {%s} exists.\n", file);
		printf("\033[0;37m");
	}
	else if (stat(file, &sb) == -1)
	{
		printf("\033[0;31m");
		printf("file {%s} does not exist.\n", file);
		printf("\033[0;37m");
	}
	if (stat(file, &sb) == 0 && sb.st_mode & S_IXUSR)
		printf("file {%s} is an executable.\n", file);
	else
		printf("file {%s} is not an executable.\n", file);
	if (stat(file, &sb) == 0 && sb.st_mode & S_IRUSR)
		printf("file {%s} is readable.\n", file);
	else
		printf("file {%s} is not readable.\n", file);
	if (stat(file, &sb) == 0 && sb.st_mode & S_IWUSR)
		printf("file {%s} is writable.\n", file);
	else
		printf("file {%s} is not writable.\n", file);
	return (0);
}

int		tests(int ac, char **av, char **env)
{
	t_msh add;
	ft_set_all_paths(&add, env);
	int i = 0;
	DIR	*dir;
	struct dirent *p;
	struct stat sb;
	char line[80];
	char *words[80];
	char *tok;
	char *sep = " ";
	strcpy(line, "< infile ls -l | wc -al > outfile | echo -n bonjour | grep line >> outfile");
	tok = strtok(line, sep);
	printf("\n\n\n\n");
	while (tok != NULL)
	{
		words[i] = strdup(tok);
		if (ft_len(words[i]) == 1 || ft_len(words[i]) == 2)
		{
			if (words[i][0] == '|')
			{
				printf("\n{%s} is a pipe\n\n", words[i]);
				printf("This section will have to manage all input generated by the previous\n");
				printf("commands and transmit it to the command after that pipe. Theses lines\n");
				printf("will be used as input for the command that comes after the delimiter.\n\n");
			}
			if (words[i][0] == '<' && !words[i][1])
			{
				printf("\n{%s} is an input redirection\n\n", words[i]);
				printf("This section will have to check if the next word is a file and, if it is,\n");
				printf("take input from that file (dup2(fd, STDIN)) and display the result of the command.");
				printf("If no file is specified the rediretion will take input from STDIN and display the result.\n\n");
			}
			if (words[i][0] == '<' && words[i][1] == '<')
			{
				printf("\n{%s} is a here_doc redirection\n\n", words[i]);
				printf("This section will have to save the next word as delimiter for the end of reading\n");
				printf("then read the input from STDIN and save all the lines until the word is found.\n");
				printf("The saved lines will be used as input for the command following that delimiter\n\n");
			}
			if (words[i][0] == '>' && !words[i][1])
			{
				printf("\n{%s} is a TRUNC output redirection\n\n", words[i]);
				printf("If a filename is specified, this redirection will output the result of the command\n");
				printf("in said file after setting the file to 0 size. all data inside the file will be truncated\n");
				printf("and the new output will replace it. If the file does not exists it will be created. If the\n");
				printf("file exists but the permissions are unsufficient, an error will be returned.\n\n");
			}
			if (words[i][0] == '>' && words[i][1] == '>')
			{
				printf("\n{%s} is an APPEND output redirection\n\n", words[i]);
				printf("If a filename is specified, this redirection will output the result of the command\n");
				printf("in said file appended after the last byte of data. If the file does not exists it will be created.\n");
				printf("If the file exists but the permissions are unsufficient, an error will be returned.\n\n");
			}
		}
		if (words[i][0] == '-' && ((words[i][1] >= 'A' && words[i][1] <= 'Z') || (words[i][1] >= 'a' && words[i][1] <= 'z')))
		{
			printf("\033[0;34m");
			printf("\n{%s} is an option/keyword to the previous command {%s}\n", words[i], words[i - 1]);
			printf("This option has to be saved in a char** for execve.\n\n");
			printf("\033[0;37m");
		}
		file_type_check(&add, words[i]);
		tok = strtok(NULL, sep);
		i++;
	}
	words[i] = tok;
	exit(EXIT_SUCCESS);
}

int	main(int ac, char **av, char **env)
{
	t_msh add;
	char	*all_paths;
	char	**paths;
	int i = 0;

	all_paths = NULL;
	paths = NULL;
	all_paths = ft_get_paths(env);
	printf("{%s}\n", all_paths);
	paths = ft_split_env(&add, all_paths, paths);
	while (paths[i])
	{
		printf("[%s]\n", paths[i]);
		i++;
	}
	return (0);
}
